#!/usr/bin/env python3
"""
Simple PentestSidecar MCP Server - Container hosting with sidecar architecture for pentesting.
"""

import os
import sys
import logging
import asyncio
import json
import subprocess

from datetime import datetime
from mcp.server.fastmcp import FastMCP
import httpx

# Configure logging to stderr
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    stream=sys.stderr
)
logger = logging.getLogger("pentestsidecar-server")

# Initialize MCP server - NO PROMPT PARAMETER!
mcp = FastMCP("pentestsidecar")

# === UTILITY FUNCTIONS ===

def run_command(command):
    """Run a shell command asynchronously and return output or error."""
    try:
        result = subprocess.run(
            command,
            capture_output=True,
            text=True,
            shell=True,
            timeout=30
        )
        if result.returncode == 0:
            return f"✅ Output:\n{result.stdout}"
        else:
            return f"❌ Error:\n{result.stderr}"
    except subprocess.TimeoutExpired:
        return "⏱️ Command timed out after 30 seconds"
    except Exception as e:
        return f"❌ Error running command: {str(e)}"

# === MCP TOOLS ===

@mcp.tool()
async def list_containers(args: str = "") -> str:
    """List all running containers including sidecars."""
    logger.info("Listing all containers")
    cmd = "docker ps --format '{{json .}}'"
    output = run_command(cmd)
    if output.startswith("✅ Output"):
        lines = output[len("✅ Output:\n"):].strip().split("\n")
        try:
            containers = [json.loads(line) for line in lines if line.strip()]
            formatted = "\n".join(f"- {c['Names']} ({c['Image']}) [ID: {c['ID']}]" for c in containers)
            return f"📊 Running Containers:\n{formatted}"
        except Exception as e:
            return f"❌ Error parsing container list: {str(e)}"
    else:
        return output

@mcp.tool()
async def start_container(image: str = "", container_name: str = "", sidecar_image: str = "") -> str:
    """Start a container with optional sidecar container for monitoring/logging."""
    if not image.strip():
        return "❌ Error: Container image is required"
    if not container_name.strip():
        return "❌ Error: container_name is required"

    logger.info(f"Starting container '{container_name}' with image '{image}'")
    # Start main container detached
    cmd_main = f"docker run -d --name {container_name} {image}"
    res_main = run_command(cmd_main)
    if not res_main.startswith("✅ Output"):
        return f"❌ Failed to start main container: {res_main}"

    if sidecar_image.strip():
        sidecar_name = f"{container_name}-sidecar"
        logger.info(f"Starting sidecar container '{sidecar_name}' with image '{sidecar_image}'")
        cmd_sidecar = (
            f"docker run -d --name {sidecar_name} "
            f"--link {container_name} "
            f"{sidecar_image}"
        )
        res_sidecar = run_command(cmd_sidecar)
        if not res_sidecar.startswith("✅ Output"):
            # Attempt to clean up main container on failure
            run_command(f"docker rm -f {container_name}")
            return f"❌ Failed to start sidecar container: {res_sidecar}"
        return f"✅ Started container '{container_name}' and sidecar '{sidecar_name}'"
    else:
        return f"✅ Started container '{container_name}' without sidecar"

@mcp.tool()
async def stop_container(container_name: str = "") -> str:
    """Stop a container and its sidecar gracefully."""
    if not container_name.strip():
        return "❌ Error: container_name is required"
    logger.info(f"Stopping container '{container_name}' and associated sidecar")
    sidecar_name = f"{container_name}-sidecar"
    # Stop main container
    stop_main = run_command(f"docker stop {container_name}")
    # Stop sidecar container if exists
    stop_sidecar = run_command(f"docker stop {sidecar_name}")
    # Remove both containers forcefully after stop attempt
    rm_main = run_command(f"docker rm -f {container_name}")
    rm_sidecar = run_command(f"docker rm -f {sidecar_name}")
    return (
        f"✅ Stopped and removed '{container_name}':\n{stop_main}\n"
        f"✅ Stopped and removed '{sidecar_name}':\n{stop_sidecar}"
    )

@mcp.tool()
async def get_logs(container_name: str = "", tail: str = "100") -> str:
    """Fetch logs from container, default last 100 lines."""
    if not container_name.strip():
        return "❌ Error: container_name is required"
    try:
        tail_int = int(tail)
    except ValueError:
        return f"❌ Error: Invalid tail value '{tail}'"
    logger.info(f"Fetching last {tail_int} log lines from '{container_name}'")
    cmd = f"docker logs --tail {tail_int} {container_name}"
    return run_command(cmd)

@mcp.tool()
async def run_pentest_tool(
    container_name: str = "",
    tool_name: str = "",
    target: str = ""
) -> str:
    """Run a pentesting tool inside specified container against target."""
    if not container_name.strip():
        return "❌ Error: container_name is required"
    if not tool_name.strip():
        return "❌ Error: tool_name is required"
    if not target.strip():
        return "❌ Error: target is required"
    logger.info(f"Running pentesting tool '{tool_name}' on target '{target}' in container '{container_name}'")
    # Common pentest tools like 'nmap', 'nikto', 'zap-cli', assumed installed in container
    cmd = f"docker exec {container_name} {tool_name} {target}"
    return run_command(cmd)

@mcp.tool()
async def validate_container(container_name: str = "") -> str:
    """Validate container health and check for crashes."""
    if not container_name.strip():
        return "❌ Error: container_name is required"
    logger.info(f"Validating container '{container_name}' status")
    # Check if container is running
    cmd_status = f"docker inspect -f '{{{{.State.Running}}}}' {container_name}"
    status = subprocess.run(cmd_status, capture_output=True, text=True, shell=True)
    if status.returncode != 0:
        return f"❌ Error: Could not inspect container {container_name}"
    if status.stdout.strip() != "true":
        return f"⚠️ Container '{container_name}' is not running"
    # Check for recent container restarts or crashes
    cmd_restarts = f"docker inspect -f '{{{{.RestartCount}}}}' {container_name}"
    restarts = subprocess.run(cmd_restarts, capture_output=True, text=True, shell=True)
    restarts_count = restarts.stdout.strip() if restarts.returncode == 0 else "unknown"
    return f"✅ Container '{container_name}' is running. Restart count: {restarts_count}"

# === SERVER STARTUP ===
if __name__ == "__main__":
    logger.info("Starting PentestSidecar MCP server...")
    try:
        mcp.run(transport='stdio')
    except Exception as e:
        logger.error(f"Server error: {e}", exc_info=True)
        sys.exit(1)
